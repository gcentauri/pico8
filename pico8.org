* Pico 8

*_local links_*  

  [[~/pico-8/pico-8.txt][Manual]]
  [[~/.lexaloffle/pico-8]]

*** Org file todo
**** TODO Token Count
  - it would be nice to be able to have a way to show the token count in the org
    file.  should check out picotools
**** TODO table of named code blocks in this file


** Log
*** Supermarket Spree tutorial - tutorials as resume

i keep noticing how beginners define functions in a strange 
way.  its a habit though, and the model comes from _init(), 
_update(), and _draw() as well.  we end up with a lot of 
definitions like:

#+BEGIN_SRC lua
function draw_stuff()
spr(blah, blah,..)
end

function do_other_stuff()
  if then
    do ...
  else do ...
  end
end
#+END_SRC

suddenly, data and logic are all intermixed and we are just
randomly changing variables trying to get something to work.

what we really want to do is define our stuff as data, and 
THEN think about doing stuff with it.  this is where our 
functions of FOR loops and IF statements comes in.

with pico 8 we can immediately do stuff with graphical, audio,
and user input data.  but my first stumbling block in the world
of programming was in understanding structured data.

**** Tables

in Lua we have tables to build data structures.  Pico-8 gives
us a bunch of predefined things to work with.  using the SPR()
function to draw a sprite is using a data structure designed
to point to bits in the Pico 8 cart memory.  its function is 
to copy the data from the spritesheet onto the screen.

this is all pretty complicated so why don't we start off 
making our game by using tables in a really boring way?  we
can also connect it with some graphics and drawing too, for
some fun times later ;)

I was thinking about dumb programming examples of lists and
items on lists being represented as data, and i had the idea
of a shopping basket.  food items, etc, in your cart.  each
item could have a price, a sprite, etc... this -> supermarket
spree game where you randomly generate a supermarket map of 
isles and products on shelves to grab in a time limit.

our first task though will be to build the cash register that
calculates the end of the game.  imagine a screen coming up 
that would draw a sprite of the product and do a cost * number
calculation to add to a running total.

we can use tables in two different ways here.

1. Shopping Cart

this is just a list. in Lua it is more accurately an array, 
and we'd have to write some functions to deal with it in a
list like way. so i might call it a list, because thats how
i'm thinking of it.

but Lua makes it super easy to visualize our data too. so,
an array can be written just like a list:

#+BEGIN_SRC lua
  shopping_cart = {--start our list
     "apples",
     "bananas",    --note the commas
     "carrots",    --and how our items
     "daikon",     --are all strings
     "eggplant",
     "fennel",
     "grapes",
  } --end our list     
#+END_SRC

to get our items back from the list you ask for them
by number.  ~shopping_cart[1]~ will return the string "apples"
and ~shopping_cart[5]~ will return "eggplant".

*** Developing an Iterative Tutorial Fri Nov 25 02:40:40 CST 2016
  finally getting a solid base for drawing and animating shapes. now that
  the basic data structures make sense and we have higher order functions
  like map, i believe there would be a nice clear way to illustrate some
  programming basics, includng some advanced but logical techniques to
  make everything smooth (like iterators and higher order functions)

  perhaps i can develop a tutorial bit by bit focusing on using tables as
  sort of structs or hash tables (like posn = {x=3,y=4}) etc... and also
  using tables as "lists" that are actually arrays.  

  if we start out by developing these drawing functions with simply a posn
  structure (just storing x,y data) and make functions that can draw more
  complex shapes by organizing the posns and mapping draw functions over
  lists of posns, or edge-lists for polygons etc... then later when we
  want to animate them, perhaps we can use Lua's metatables to make 
  vectors using the posn structure and metamethods, metatables...??

*** Iterators Supreme Thu Nov 24 20:00:46 CST 2016
after some experimentation, it turns out that doing metatables properly 
allows for my vectors to take up much less memory, and with the generic FOR
pattern using an iterator i can draw lines between about 12000 points very
fast.  Using the recursive tail call version seems prettier, and saves tokens
i think?, but just isn't fast.  drawing 6000 lines takes quite a while, so
to do any complex graphics for games this would not work.

it appears (for now) that the limitations of Pico 8 (only 1M memory) require
the more idiomatic Lua, however, the Scheme-y way could potentially be 
optimized? there's a Lua way of constructing linked lists I found that may
be a better way to use list processing.

**** However, Tables

Using Lua tables as they are in the context of Pico 8 makes sense, and I 
think there may be a nice pedagogical way to illustrate data structures 
using tables in their flexible way.  i think a combination of using key,
value pairs as a struct type of data and using tables as arrays still allows
for higher-order / maybe functional style programming

I'd like to be able to have table that is an array of shapes, and draw
those shapes with a function like map(draw_shape, list_of_shapes) 

this implies a data structure for Shapes that would encompass all our 
drawable shapes (circ, rect, line, poly?) /i'm wondering if poly can be
accomplished with a map function too?/ and a function draw_shape that could
generically draw shapes.  

**** higher-order connect-dots / poly

if i first make a function that can take a list of posns/vecs and turn it
into an edge-list then can i use something like map(draw_line, edge-list)
to perform connect-dots or polygon drawing?

*** Memory and Tail Calls Sat Nov 19 00:12:22 CST 2016
while trying to decide on a model to follow for drawing stuff... I was 
working on the connect_dots function which takes a list of posns or vecs
and draws a line between each point and the one following on the list.

both versions work, but I discovered some issues with either, due to the
pico8 limitations (and probably other stuff too).  I was trying to make a 
list with 1000 points on it, and with my original recursive =connect_posns=
i ran out of memory as the draw function was running.  too many function
call expansions for the stack.  however, Lua supports [[http://www.lua.org/pil/6.3.html][proper tail calls]]
which means if the final thing a function does is to call a function.

after changing the =connect_posns= function, i was able to run it on a list
of 6000 points with no trouble (aside from the time it took to draw).  
clearly, any recursive based techniques in Pico 8 will need to use tail
calls to work efficiently.

on the other hand, the iterator based connect_dots function had no trouble
with 1000 iterations (and wouldn't have trouble with 6000 either) but...
the way that vectors are implemented requires quite a bit more memory for
each point than the simple posn = {x,y} implementation.  i was not able to
create a list even 2000 items long.  running stat(0) (to get the memory) 
returns 652.29 after making a table with 1000 vectors.  A table with 6000
posns is only 501.101 in memory.

This seems really wrong to me, and I wonder if the vector implementation is
creating way too many tables and that I'm not doing the metatable thing 
the right way.  Each vector should be able to refer to the same table for
the metamethods, rather than each have their own metamethod table right?
I dunno, its not looking like the closure method for vectors carrying around
all those functions  is the best for pico8?  

in terms of iterators v tail calls, they seem to both work at this point.
for now i think keeping data structures small and writing functions 
separately (rather than wrapping data and functions together like OOP) might
be best for pico projects?

*** Structs or no structs? Fri Nov 18 18:22:11 CST 2016

For a minute, I wanted to figure out how to implement scheme like structs in
Lua, in order to more closely mimic the HtDP curricula.  While this might 
make sense if I were doing a large Lua project, I'm not sure how it really
fits into Pico 8.  It may be making more work than necessary.  However, I
think there could be potential to save tokens?  If I made a struct building
function, then arbitrary data objects could be created along with getter and
setter functions with a simple assignment, e.g...

  : posn = struct(x,y)
  : entity = struct(posn,dx,dy,ddy,kind,life)

those lines should give us a constructor function like =posn()= or =entity()=
that would create a table or a closure with getter and setter functions.
an additional feature would be a predicate function like posn? or entity?,
but for pico 8 maybe it isnt important to manage types like that?  or perhaps
for clearest understanding it is good to have that?

*** Scheming about geometry Mon Nov 14 23:54:26 CST 2016

seems like for teaching kids, focusing on the HtDP model of 2d geometry 
and structs, maybe i can use Pico 8 to emulate that  I'm going to try
and use metatables to create the functionality of struct from scheme

*** Sat Nov  5 21:17:09 CDT 2016

Finally initialized a git repo to get going on version control.  This org
document currently contains working functions that can be referred to by
name in the Tangles section.  Combined with the pico8 header and footer, 
you can construct Pico 8 game carts with org-babel-tangle. 

I am currently trying out two different versions of making a vector object
for drawing with.  One uses metatables heavily, and the other uses closures
to represent objects.  I am leaning toward the closures method, as it seems
to lead to "powerful programming techniques" and feels like it has a cleaner
model.  the vector 'objects' have local variables x and y, but the way to
access those is not by a table access like vector["x"] (or vector.x) returning
a table value stored there, rather vector.x() is a function which returns the
value of the local variable x which is closed over in the definition of x()

*** Initial Impressions
Pico 8 uses a small version of the Lua programming language, which I am 
realizing to my delight, is a strange sort of cousin of scheme and other
interpreted languages that i am used to.  The main strangeness is the fact
that there is only one data structure, the table.  so i have to learn how to
wrangle the Lua table structure to work how i need my data to be.  its a 
little less straight forward than the list-processing style i'm used to, but
i'm beginning to see its usefulness.  the main issue is that one has to be
really savvy with design of data and be clear and consistent.

**** closures

I  discovered that Lua supports closures, and some powerful
functional programming tools.  I should really look deeply into that aspect
of it and practice it in making Pico 8 games, I think it could be a nice 
advantage.  I should look into using closures for sprite animation, I've been
thinking of how to do multiframe animations from a single event in a game, 
and it seemed like i'd need to initialize a new counter every time.  but
with closures i can probably just have a way of getting my 
counters to work all wrapped up nicely instead of floating around.

**** code quirks

 - the pico editor is only 32 characters wide, so the style here might
   reflect that.  it feels right to try to make the code as readable 
   as possible yet terse.

 - theres a trick in lua for commenting code blocks.  if you start
   a block on one line with "--[[" [[and then on the line following the
   code block, use "--]]]]".  If you then add a single - at the beginning
   of the block comment, it will uncomment out the code inside the
   block.  very handy.  This might allow people to put debug code into
   their games and then turn it on and off quite easily.
   

** Pico 8 Cart requirements 					    :require:
The p8 file won't load properly without the header and cart data. 
We could potentially save chunks of cart data here to import into p8 carts
as well.

**** Pico 8 header 						    :require:

Have to have this to construct a proper cart

#+name: pico8_header
#+BEGIN_SRC lua
  pico-8 cartridge // http://www.pico-8.com
  version 8
  __lua__
#+END_SRC

**** Default cart data 						    :require:

this too...

#+name: default_cart_data
#+BEGIN_SRC lua
  __gfx__
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00700700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00077000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00077000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00700700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  __gff__
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  __map__
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  __sfx__
  000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  __music__
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344
  00 41424344

#+END_SRC




** Tangles
*** First Game Engine
   
#+name: engine
#+BEGIN_SRC lua :tangle engine.p8 :padline no :noweb yes
  <<pico8_header>>
     
  --utilites
  <<list_iter>>
  <<fmap>>

  --prototype vector object
  <<vec>>

  --polygon stuff
  <<make_edge_list>>
  <<draw_edge>>
  <<poly>>

  --variation to connect posns
  <<connect_dots>>
  <<connect_poly>>

  <<default_cart_data>>
#+END_SRC


** Utils
 since pico8 doesn't come with Lua's standard library, it is almost like
 working with a basic Scheme, and i have to write some standard utilities
 for basic progamming things.
*** redefine functions with closures 				    :closure:
in this example, the predefined function print is being redefined to print the values
of table entries when given a table rather than just printing "table".  the issue is that
we still need the old print function, but we'd like to avoid accidentally calling it 
somehow.  using the local definition keeps the original print in a private variable

see the lua book [[http://www.lua.org/pil/6.1.html]]

#+BEGIN_SRC lua
  local oldprint = print

  print = function(s)
    if type(s) == "table" then
      for _,v in pairs(s) do
        oldprint(v)
      end
    else oldprint(s) end
  end

  print({"foo","bar","baz"})
#+END_SRC
*** TODO Structs in Lua?			     :functional:data:struct:

Maybe using metatables to emulate scheme structs would be a clear way to manage data?

#+name: struct
#+BEGIN_SRC lua

#+END_SRC

to make structs work, we need to have a constructor, a predicate, and accessors
we can also use metamethods to define equality checks too?

i found a [[http://lua-users.org/wiki/StrictStructs][page on the Lua wiki]] that describes making 'strict-structs', while i
was hoping to make my own code for it, this implementation seems like good 
idiomatic Lua and perhaps I can just annotate it to understand.

#+name: strict-struct
#+BEGIN_SRC lua
  -- struct.lua
  --- defining a struct constructor ---
  local struct_mt = {
          -- instances can be created by calling the struct object
          __call = function(s,t)
                  local obj = t or {}  -- pass it a table (or nothing)
                  local fields = s._fields
                  -- attempt to set a non-existent field in ctor?
                  for k,v in pairs(obj) do
                          if not fields[k] then
                                  s._error_nf(nil,k)
                          end
                  end
                  -- fill in any default values if not supplied
                  for k,v in pairs(fields) do
                          if not obj[k] then
                                  obj[k] = v
                          end
                  end
                  setmetatable(obj,s._mt)
                  return obj
          end;
  }

  -- creating a new struct triggered by struct.STRUCTNAME
  struct = setmetatable({},{
          __index = function(tbl,sname)
                  -- so we create a new struct object with a name
                  local s = {_name = sname}
                  -- and put the struct in the enclosing context
                  _G[sname] = s
                  -- the not-found error
                  s._error_nf = function (tbl,key)
                          error("field '"..key.."' is not in "..s._name)
                  end
                  -- reading or writing an undefined field of this struct is an error
                  s._mt = {
                          _name = s._name;
                          __index = s._error_nf;
                          __newindex = s._error_nf;
                  }
                  -- the struct has a ctor
                  setmetatable(s,struct_mt)
                  -- return a function that sets the struct's fields
                  return function(t)
                          s._fields = t
                  end
          end
  })
#+END_SRC

*** List style functions 				   :lists:functional:
**** car, cdr, cons
#+name: car
#+BEGIN_SRC lua
  function car(arr)
     return arr[1]
  end
#+END_SRC

this is the cdr function, lets you get all but the first element of a list

#+name: cdr
#+BEGIN_SRC lua
  function cdr(arr)
     local new_array = {}
     for i = 2, #arr do
        add(new_array, arr[i])
     end
     return new_array
  end
#+END_SRC

#+name: cons
#+BEGIN_SRC lua
  function cons (car, cdr)
     local new_array = {car}
     for _,v in pairs(cdr) do
        add(new_array, v)
     end
     return new_array
  end
#+END_SRC

**** collection of all functions
#+name: list-functions
#+BEGIN_SRC lua
<<car>>
<<cdr>>
<<cons>>
#+END_SRC

*** Iterators
Iterators are used in the generic FOR loop in Lua. Similar to what I have
seen in Python, and i think is what is called generative recursion. 
Iterators are functions that can return items from a collection but also
the state of the iteration like what index you're currently on.
**** List iterator 						  :iterator:engine:
this is an example of how to write an iterator for the generic FOR loop
in Lua. you can use this to traverse a table formed like a list.
#+name: list_iter
#+BEGIN_SRC lua
--[[ use in generic for loops 
to iterate over an array(list)]]
function list_iter (t)
 local i, n = 0, #t

 return function()
  i = i + 1
  if i <= n then 
   return t[i],i,n 
  end
 end
end

#+END_SRC

*** Debugging utils

#+name: logprint
#+BEGIN_SRC lua
  function logprint(str)
     printh(str, log.txt)
  end
#+END_SRC
    
*** Higher order functions
  I'd like to try implementing map, filter, fold, etc... and see if they are
  effective ways to draw lists of objects to try and replace the generic
  FOR with list_iter pattern.

#+name: fmap
#+BEGIN_SRC lua
  --[[ fmap: function table -> table
  maps a function onto every item 
  on a list 
  e.g: fmap(double, {1,2,3})-> {2,4,6}
  --]]
  function fmap(func, tbl)
       local newtbl = {}
       for i,v in pairs(tbl) do
           newtbl[i] = func(v)
       end
       return newtbl
  end

#+END_SRC

** Graphics
*** HtDP style 						       :old:refactor:geometry:

perhaps this style is better to teach younger people or beginners. learning programming
and math together is important, but trying to introduce new concepts like vector right
away is kinda too much.  the behavior we can get with vector models will pose problems
for this more geometric approach.  I think my main question is whether or not to start
with mutable structures using closures or just go straight forward functional style with
non mutating structures

#+name: htdp
#+BEGIN_SRC lua :tangle htdp.p8 :noweb yes :padline no
  <<pico8_header>>
  --[[list processing]]--
  <<list-functions>>

  --[[functional drawing utils]]--
  <<make_posn>>
  <<move_posn>>
  <<dist_apt>>
  <<rotate>>
  <<wrapped_p8_drawing_functions>>
  <<connect_posns>>

  --[end of drawing utils]--
  <<default_cart_data>>
#+END_SRC

**** Posn constructor

It feels nice to me to be able to wrap up the x,y coordinates as one data structure.
here we just have a function to take x and y as parameters and return a table.

Since in lua we can get and set those values as normal table values, the constructor
is all we need at first glance.  later on, maybe I'd like to do a version with some
metamethods.  

#+Name: make_posn
#+BEGIN_SRC lua 
  --[[ make_posn:
  number number -> posn
  a posn is a structure where
  x and y are real numbers]]--
  function make_posn(x,y)   
   return {x=x,y=y}
  end

#+END_SRC


**** geometry functions

#+name: move_posn
#+BEGIN_SRC lua
  --[[ move_posn:
  posn, number, number -> posn
  moves a posn by dx and dy]]--
  function move_posn(posn,dx,dy)
   local new_posn = make_posn(
                    posn.x + dx,
                    posn.y + dy)
   return new_posn
  end

#+END_SRC

#+name: dist_apt
#+BEGIN_SRC lua
  --[[ dist_apt:
  posn posn -> number
  use pythagorean theorem to
  find the distance btw two posns]]
  function dist_apt(posn1,posn2)
   local a,b = posn2.x - posn1.x,
               posn2.y - posn1.y
   local c = sqrt(a*a + b*b)
   return c
  end

#+END_SRC

#+name: rotate
#+BEGIN_SRC lua
  --[[ rotate:
  posn posn number -> posn
  rotate a posn around a center 
  by angle -1.0 - 1.0 ]]--
  function rotate(p,c,a)
   local rotated,r = {},
                     dist_apt(p,c)
   rotated.x = c.x+(r*cos(a))
   rotated.y = c.y+(r*sin(a))
   return rotated
  end

#+END_SRC

**** Drawing Functions

To make posns worthwhile, we ought to wrap the pico8 drawing functions 
to take posns n place of x and y values, right?  The other option is to
make structures for circle, rect, etc, and have draw_circle functions to
draw those structures.  Somehow it feels like any of this is slight overkill
but it really depends on how often the drawing functions are used.

#+name: wrapped_p8_drawing_functions
#+BEGIN_SRC lua
  local p8line = line
  function line(posn_a,posn_b)
    p8line(posn_a.x, posn_a.y,
         posn_b.x, posn_b.y)
    return true
  end      

  local p8pget = pget
  function pget(posn)
    return p8pget(posn.x, posn.y)
  end

  local p8pset = pset
  function pset(posn,...)
     local c = ...
     if c then
        p8pset(posn.x,
               posn.y,
               c)
     else p8pset(posn.x,posn.y)
     end
  end

  local p8circ = circ
  function circ(posn, r, ...)
    local c = ...
    if c then
      p8circ(posn.x, posn.y,
             r, c)
    else
      p8circ(posn.x, posn.y, r)
    end
  end

  local p8circfill = circfill
  function circfill(posn, r, ...)
    local c = ...
    if c then
      p8circfill(posn.x, posn.y,
             r, c)
    else
      p8circfill(posn.x, posn.y, r)
    end
  end

  local p8rect = rect
  function rect(p1,p2,...)
     local c = ...
     if c then
        p8rect(p1.x, p1.y,
               p2.x, p2.y, c)
     else
        p8rect(p1.x, p1.y,
               p2.x, p2.y)
     end
  end

  local p8rectfill = rectfill
  function rectfill(p1,p2,...)
     local c = ...
     if c then
        p8rectfill(p1.x, p1.y,
               p2.x, p2.y, c)
     else
        p8rectfill(p1.x, p1.y,
               p2.x, p2.y)
     end
  end
        
#+END_SRC

#+name: connect_posns
#+BEGIN_SRC lua
  --[[ connect_dots
  list-of-posns -> true
  draws a solid line between each 
  ]]--
  function connect_posns(alop)
   local rest = cdr(alop)
   if not rest[1] then
     return true
   else 
     line(car(alop), car(rest))
     return connect_posns(rest)
   end
  end

  --[[tests
  local a = make_posn(5,63)
  local b = make_posn(64,30)
  local c = make_posn(122,63)
  local tri = {a,b,c}
  color(8)
  connect_posns(tri)

  local t = {}
  for i=1,1000 do
   add(t,make_posn(rnd(127),rnd(127)))
  end
  color(9)
  connect_posns(t)
  --]]
#+END_SRC


*** Vectors 						    :graphics:vector:
**** Basic vector prototype 					     :engine:
#+name: vec
#+BEGIN_SRC lua
  vec = {}
  vec.__index = vec

  vec.__add = function(a,b)
      return vec(a.x + b.x, 
                 a.y + b.y) end
    
  vec.__sub = function(a,b)
      return vec(a.x - b.x,
                 a.y - b.y) end
     
  vec.__mul = function(a,b)
    --scalar multiplication
      if type(a) == "number" then
        return vec(b.x * a,
                   b.y * a) 
      elseif type(b) == "number" then
        return vec(a.x * b,
                   a.y * b)
      end

    --dot product
      return a.x * b.x + a.y * b.y
      end -- mul function

  function vec:mag()
    return sqrt(self.x*self.x 
              + self.y*self.y)
  end

  function vec:show()
    print("("..self.x..","
             ..self.y..")")
  end

  function vec.new(x,y)
    return setmetatable({
      x = x or 0,
      y = y or 0}, vec)
  end

  setmetatable(vec, {  
    __call = function(v,  ...)
      return v.new(...) end,
          })

  --[[tests:
  a = vec(43,63)
  b = vec(80,10)
  c = a + b
  d = c - b
  e = vec(-3,-3)
  f = e + a 

  t = {a,b,c,d,e,f}

  for i in all(t) 
  do i:show() end

  print("dot product of f and a: "..f * a)
  print("dot product of e and a: "..e * a)
  print("magnitude of a: "..a:mag())
  print("magnitude of e: "..e:mag())
  --]]
#+END_SRC

**** simple metatable example 					 :metatables:

this is from a [[http://www.lexaloffle.com/bbs/?tid=3342][post on the lexaloffle board]] using metatables to function as
a prototype object. i like its simplicity, and the token count is fairly low

#+name: vector_metatable
#+BEGIN_SRC lua
  local vec = {}

  function vec.new(x,y)
    local t = {
       x = x,
       y = y
    }
    setmetatable(t,vec)
    return t
  end

  function vec.__add(a,b)
    return vec.new(
       a.x + b.x,
       a.y + b.y
    )
  end

  function vec.__sub(a,b)
    return vec.new(
       a.x - b.x,
       a.y - b.y
    )
  end

  function vec.__mul(a,b)
    if type(a) == "number" then
       return vec.new(
                b.x * a, b.y * a)
    elseif type(b) == "number" then
       return vec.new(
                a.x * b, a.y * b)
    end
    return a.x * b.x + a.y * b.y
  end

  function vec.__eq(a,b)
    return a.x == b.x and a.y == b.y
  end

  function vec_string(a)
    return "("..a.x..", "..a.y..")"
  end

  --[[ tests
  local a = vec.new(2,2)
  local b = 4 * a 
  local c = a + b
  print(vec_string(a))
  print(vec_string(b))
  print(vec_string(c))
  --]]
#+END_SRC
 
**** vector with closures 			    :closure:vector:graphics:

the way this is now uses seemingly too much memory per object.


#+name: vector_closure_old
#+BEGIN_SRC lua
  vec = setmetatable({},
   {__index = vec,
    __call = function(v,...)
      return v.new(...) end,
   }) 

  function vec.new(x,y)
    local self = {}
    
    x = x or 0
    y = y or 0

    --getters
    self.x = function()
      return x end        
    self.y = function()
      return y end
    --setters
    self.setx = function(n)
       x = n end
    self.sety = function(n)
       y = n end

    --metamethods do vector math
    local meta = {
      __add = function(_,v)
        return vec(
          x + v.x(), 
          y + v.y())
      end,
     
      __sub = function(_,v)
        return vec(
          x - v.x(),
          y - v.y())
      end,
     
      __mul = function(a,b)
        --scalar multiplication
        if type(a) == "number" then
        return vec(b.x() * a,
                   b.y() * a) 
        elseif type(b) == "number" then
        return vec(x * b,
                   y * b)
        end
        --dot product
        return x * b.x() + y * b.y()
      end,
    }  

    self.mag = function()
      return sqrt(x*x + y*y)
    end

    self.show = function()
      print("("..x..","..y..")")
    end

    self.pget = function()
      pget(x,y) end

    self.pset = function(color)
      pset(x,y,color) end

    setmetatable(self, meta)
     
    return self
  end

  --[[tests:
  a = vec(43,63)
  b = vec(80,10)
  c = a + b
  d = c - b
  e = vec(-3,-3)
  f = e + a 

  t = {a,b,c,d,e,f}

  for _,v in pairs(t) do
   v.pset(rnd(14) + 1)
   v.show()
  end

  print("dot product of f and a: "..f * a)
  print("dot product of e and a: "..e * a)
  print("magnitude of a: "..a.mag())
  print("magnitude of e: "..e.mag())
  --]]
#+END_SRC

*** connect_dots 					  :function:graphics:

requires list_iter

this function should be able to take a list of any table with values indexed
by x and y.  it will draw a line between each pair of positions on the list

#+name: connect_dots
#+BEGIN_SRC lua
  --[[ connect_dots: list -> bool

  given a table like:
    {{x=0,y=0},{x=8,y=30},...{x,y}}
  draws a line btw each posn 
  and the following in the list.--]]

  function connect_dots(l)
   for v,i,n in list_iter(l) do
    if (i+1) <= n then
     local v1 = l[i+1]
     line(v.x, v.y, 
          v1.x, v1.y)   
    elseif (con and i==n) then
     local v1 = l[1]
     line(v.x, v.y, 
          v1.x, v1.y)
    else return true end
   end
  end

  --[[ test

  local lines = {}
  for i=1,10000 do
    add(lines, 
        vec(rnd(127),rnd(127)))
  end

  connect_dots(lines)
  --]]

#+END_SRC

*** Polygon

We can use connect_dots to draw a connected polygon pretty easily...

#+name: connect_poly
#+BEGIN_SRC lua
  --[[ poly: list-of-posns -> true
  draws a connected polygon 
  ]]
  function connect_poly(l)
    local connected = l
    add(connected,l[1])
    return connect_dots(connected)
  end

#+END_SRC

but i think we can also do it by making an edge list and using map to
draw all the edges.

#+name: make_edge_list
#+BEGIN_SRC lua
  --[[ make_edge_list: 
  list-of-posns -> edge-list

  turns a list of x,y positions 
  (or vectors) into a list of
  edges, pairs of positions 
  --]]
  function make_edge_list(l)
    local start, edges = l[1], {}   
    for v,i,n in list_iter(l) do
     local v1 = l[i+1]
     if v1 then
      add(edges, {v,v1})
     else add(edges, {v,start})end
    end
    return edges
  end
       
#+END_SRC

now we just need a function to draw edges:

#+name: draw_edge
#+BEGIN_SRC lua
  --[[ draw_edge: edge-pair ->true

  draws a line between a pair of
  posns represented by the edge ]]
  function draw_edge(e)
    local a,b = e[1],e[2]
    line(a.x, a.y, b.x, b.y)
    return true
  end

#+END_SRC

and we can define poly using fmap

#+name: poly
#+BEGIN_SRC lua
  function poly(l)
    return fmap(draw_edge,
                make_edge_list(l))
  end

#+END_SRC

*** Plot
#+name: plot
#+BEGIN_SRC lua
  -- plot a function
  -- (assume that domain and image are in the range [-1,1])
  function plot (f)
     for i=0,127 do
        local x = (i/128)*2 - 1
        local y = (f(x) + 1)/2 * 128
        pset(i, y)
     end
  end
#+END_SRC

*** Collision

    [[../p8carts/wip/clouds.p8]]

** Sound

After struggling to understand the Pico8 sound system while trying to
make a music game, I have finally discovered a part of the manual I 
ignored.  The =STAT(x)= function allows you to query the state of some of
the Pico8 machine systems, including the sound system.

=stat(16..19)= returns the index of the currently playing SFX on channels
0..3.  this means that every _update cycle we can check which sound 
effects or parts of music are currently playing.

=stat(20..23)= returns note number (0..31) on channel 0..3.  We can use
this to find out which note out of 32 notes in a pattern is currently
playing.  i used this to successfuly match a beat (that i already knew)
by using a conditional that if stat(20) == 0..4..8..12..16..etc 

this is not really detecting a beat though, I just found the right counter
to sync up to finally.  i had been trying to sync with the frame rate, 
but i was blind to this 32 note loop i had access to.  there is some code
for a piano roll visualizer that seems to read notes, and i plan to check
that out.

*** Read SFX Notes

this code is from the Piano Roll Music Visualizer by kittenm4ster:

#+name read_sfx_notes
#+BEGIN_SRC lua
  function read_sfx_notes(sfxindex)
    local notes = {}

    -- find the address of the sfx (68 bytes per sfx)
    local sfxaddr = 0x3200 + (68 * sfxindex)

    for i = 0, 31 do
      -- find the address of the note (16 bits)
      local noteoffset = (i * 2)

      -- get the two bytes of the note
      local byte1 = peek(sfxaddr + noteoffset)
      local byte2 = peek(sfxaddr + noteoffset + 1)

      notes[i] = {
        pitch = band(byte1, 63),
        volume = shr(band(byte2, 14), 1)
      }
    end

    return notes
  end
#+END_SRC


** Games
*** Pico Pow-wow

[[~/.lexaloffle/pico-8/carts/powwow/powwow.org][Pico Pow-wow]] - org file




** Tutorial
*** Dear Drew n Margaret
* Lua

** Functional Library 

#+BEGIN_SRC lua
 -- Functional Library
 --
 -- @file    functional.lua
 -- @author  Shimomura Ikkei
 -- @date    2005/05/18
 --
 -- @brief    porting several convenience functional utilities form Haskell,Python etc..
 -- map(function, table)
 -- e.g: map(double, {1,2,3})    -> {2,4,6}
 function map(func, tbl)
     local newtbl = {}
     for i,v in pairs(tbl) do
         newtbl[i] = func(v)
     end
     return newtbl
 end
 -- filter(function, table)
 -- e.g: filter(is_even, {1,2,3,4}) -> {2,4}
 function filter(func, tbl)
     local newtbl= {}
     for i,v in pairs(tbl) do
         if func(v) then
	     newtbl[i]=v
         end
     end
     return newtbl
 end
 -- head(table)
 -- e.g: head({1,2,3}) -> 1
 function head(tbl)
     return tbl[1]
 end

 -- tail(table)
 -- e.g: tail({1,2,3}) -> {2,3}
 --
 -- XXX This is a BAD and ugly implementation.
 -- should return the address to next porinter, like in C (arr+1)
 function tail(tbl)
     if table.getn(tbl) < 1 then
         return nil
     else
         local newtbl = {}
         local tblsize = table.getn(tbl)
         local i = 2
         while (i <= tblsize) do
             table.insert(newtbl, i-1, tbl[i])
             i = i + 1
         end
        return newtbl
     end
 end
 -- foldr(function, default_value, table)
 -- e.g: foldr(operator.mul, 1, {1,2,3,4,5}) -> 120
 function foldr(func, val, tbl)
     for i,v in pairs(tbl) do
         val = func(val, v)
     end
     return val
 end

 -- reduce(function, table)
 -- e.g: reduce(operator.add, {1,2,3,4}) -> 10
 function reduce(func, tbl)
     return foldr(func, head(tbl), tail(tbl))
 end
 -- curry(f,g)
 -- e.g: printf = curry(io.write, string.format)
 --          -> function(...) return io.write(string.format(unpack(arg))) end
 function curry(f,g)
     return function (...)
         return f(g(unpack(arg)))
     end
 end
 -- bind1(func, binding_value_for_1st)
 -- bind2(func, binding_value_for_2nd)
 -- @brief
 --      Binding argument(s) and generate new function.
 -- @see also STL's functional, Boost's Lambda, Combine, Bind.
 -- @examples
 --      local mul5 = bind1(operator.mul, 5) -- mul5(10) is 5 * 10
 --      local sub2 = bind2(operator.sub, 2) -- sub2(5) is 5 -2
 function bind1(func, val1)
     return function (val2)
         return func(val1, val2)
     end
 end
 function bind2(func, val2) -- bind second argument.
     return function (val1)
         return func(val1, val2)
     end
 end
 -- is(checker_function, expected_value)
 -- @brief
 --      check function generator. return the function to return boolean,
 --      if the condition was expected then true, else false.
 -- @example
 --      local is_table = is(type, "table")
 --      local is_even = is(bind2(math.mod, 2), 1)
 --      local is_odd = is(bind2(math.mod, 2), 0)
 is = function(check, expected)
     return function (...)
         if (check(unpack(arg)) == expected) then
             return true
         else
             return false
         end
     end
 end
 -- operator table.
 -- @see also python's operator module.
 operator = {
     mod = math.mod;
     pow = math.pow;
     add = function(n,m) return n + m end;
     sub = function(n,m) return n - m end;
     mul = function(n,m) return n * m end;
     div = function(n,m) return n / m end;
     gt  = function(n,m) return n > m end;
     lt  = function(n,m) return n < m end;
     eq  = function(n,m) return n == m end;
     le  = function(n,m) return n <= m end;
     ge  = function(n,m) return n >= m end;
     ne  = function(n,m) return n ~= m end;

 }
 -- enumFromTo(from, to)
 -- e.g: enumFromTo(1, 10) -> {1,2,3,4,5,6,7,8,9}
 -- TODO How to lazy evaluate in Lua? (thinking with coroutine)
 enumFromTo = function (from,to)
     local newtbl = {}
     local step = bind2(operator[(from < to) and "add" or "sub"], 1)
     local val = from
     while val <= to do
         table.insert(newtbl, table.getn(newtbl)+1, val)
         val = step(val)
     end
     return newtbl
 end
 -- make function to take variant arguments, replace of a table.
 -- this does not mean expand the arguments of function took,
 -- it expand the function's spec: function(tbl) -> function(...)
 function expand_args(func)
     return function(...) return func(arg) end
 end

#+END_SRC

** Streams

interesting implementation of lazy evaluated streams.  too bad i cant
figure out how to make the reactive. lua is inherently procedural so,
for now i think i will move to Elm to try out these ideas. 

#+BEGIN_SRC lua
  stream = {}                              

  function Buffer()                              
     local self = {}                                
     local m_data                                   
     local m_has = false                            
     local set                                      
     local get                                      
     local has                                      
     function set(_data)                            
        if m_has then                                  
           error("buffer already has data")               
        end                                            
        m_has = true                                   
        m_data = _data                                 
     end                                            
     function get()                                 
        if not m_has then                              
           error("buffer is empty")                       
        end                                            
        local value = m_data                           
        m_has = false                                  
        m_data = nil                                   
        return value                                   
     end                                            
     function has()                                 
        return m_has                                   
     end                                            
     self.set = set                                 
     self.get = get                                 
     self.has = has                                 
     return self                                    
  end                                            

  function stream.Optional()                     
     local self = {}                                
     local m_value                                  
     local m_has = false                            
     local set                                      
     local get                                      
     local remove                                   
     local has                                      
     local ifPresent                                
     function set(_value)                           
        m_has = true                                   
        m_value = _value                               
     end                                            
     function get()                                 
        return m_value                                 
     end                                            
     function remove()                              
        m_has = false                                  
        m_value = nil                                  
     end                                            
     function has()                                 
        return m_has                                   
     end                                            
     function ifPresent(func)                       
        if m_has then                                  
           func(m_value)                                  
        end                                            
     end                                            
     self.set = set                                 
     self.get = get                                 
     self.remove = remove                           
     self.has = has                                 
     self.ifPresent = ifPresent                     
     return self                                    
  end                                            
  function stream.Stream()                       
     local self = {}                                
     local filter                                   
     local limit                                    
     local skip                                     
     local stride                                   
     local map                                      
     local peek                                     
     local concat                                   
     local distinct                                 
     local sorted                                   
     local recur                                    
     local count                                    
     local forEach                                  
     local reduce                                   
     local findFirst                                
     local findLast                                 
     local toArray                                  
     local min                                      
     local max                                      
     function filter(func)                          
        local s = stream.Stream()                      
        local m_buffer = Buffer()                      
        local next                                     
        local hasNext                                  
        function next()                                
           if not s.hasNext() then                        
              error("next element does not exist")           
           end                                            
           return m_buffer.get()                          
        end                                            
        function hasNext()                             
           if m_buffer.has() then                         
              return true                                    
           end                                            
           local value                                    
           repeat                                         
              if not self.hasNext() then                     
                 return false                                   
              end                                            
              value = self.next()                            
           until func(value)                              
           m_buffer.set(value)                            
           return true                                    
        end                                            
        s.next = next                                  
        s.hasNext = hasNext                            
        return s                                       
     end                                            
     function limit(num)                            
        local s = stream.Stream()                      
        local m_count = 0                              
        local next                                     
        local hasNext                                  
        function next()                                
           if not s.hasNext() then                        
              error("next element does not exist")           
           end                                            
           m_count = m_count + 1                          
           return self.next()                             
        end                                            
        function hasNext()                             
           if not self.hasNext() then                     
              return false                                   
           end                                            
           return m_count < num                           
        end                                            
        s.next = next                                  
        s.hasNext = hasNext                            
        return s                                       
     end                                            
     function skip(num)                             
        local s = stream.Stream()                      
        local m_count = 0                              
        local next                                     
        local hasNext                                  
        function next()                                
           if not s.hasNext() then                        
              error("next element does not exist")           
           end                                            
           return self.next()                             
        end                                            
        function hasNext()                             
           while m_count < num and self.hasNext() do      
              self.next()                                    
              m_count = m_count + 1                          
           end                                            
           return m_count == num                          
        end                                            
        s.next = next                                  
        s.hasNext = hasNext                            
        return s                                       
     end                                            
     function stride(num)                           
        local s = stream.Stream()                      
        local m_count = 0                              
        local m_buffer = Buffer()                      
        local next                                     
        local hasNext                                  
        function next()                                
           if not s.hasNext() then                        
              error("next element does not exist")           
           end                                            
           return m_buffer.get()                          
        end                                            
        function hasNext()                             
           if m_buffer.has() then                         
              return true                                    
           end                                            
           while m_count < num and self.hasNext() do      
              self.next()                                    
              m_count = m_count + 1                          
           end                                            
           if m_count == num then                         
              m_count = 0                                    
              m_buffer.set(self.next())                      
              return true                                    
           else                                           
              return false                                   
           end                                            
        end                                            
        s.next = next                                  
        s.hasNext = hasNext                            
        return s                                       
     end                                            
     function map(func)                             
        local s = stream.Stream()                      
        local next                                     
        local hasNext                                  
        function next()                                
           return func(self.next())                       
        end                                            
        s.next = next                                  
        s.hasNext = self.hasNext                       
        return s                                       
     end                                            
     function peek(func)                            
        local s = stream.Stream()                      
        local next                                     
        local hasNext                                  
        function next()                                
           local next = self.next()                       
           func(next)                                     
           return next                                    
        end                                            
        s.next = next                                  
        s.hasNext = self.hasNext                       
        return s                                       
     end                                            
     function concat(s)                             
        return stream.concat(self, s)                  
     end                                            
     function distinct()                            
        local s = stream.Stream()                      
        local m_visited = {}                           
        local m_buffer = Buffer()                      
        local next                                     
        local hasNext                                  
        function next()                                
           if not self.hasNext() then                     
              error("next element does not exist")           
           end                                            
           return m_buffer.get()                          
        end                                            
        function hasNext()                             
           if m_buffer.has() then                         
              return true                                    
           end                                            
           if not self.hasNext() then                     
              return false                                   
           end                                            
           local value = self.next()                      
           while m_visited[value] do                      
              if not self.hasNext() then                     
                 return false                                   
              end                                            
              value = self.next()                            
           end                                            
           m_visited[value] = true                        
           m_buffer.set(value)                            
           return true                                    
        end                                            
        s.next = next                                  
        s.hasNext = hasNext                            
        return s                                       
     end                                            
     function sorted(comparator)                    
        local array = self.toArray()                   
        table.sort(array, comparator)                  
        return stream.array(array)                     
     end                                            
     function recur(n)                              
        local s = stream.Stream()                      
        local m_buffer = stream.Optional()             
        local m_count = 1                              
        local next                                     
        local hasNext                                  
        function next()                                
           if not s.hasNext() then                        
              error("next element does not exist")           
           end                                            
           m_count = m_count + 1                          
           return m_buffer.get()                          
        end                                            
        function hasNext()                             
           if self.hasNext() then                         
              if m_buffer.has() and m_count < n then         
                 return true                                    
              else                                           
                 m_buffer.set(self.next())                      
                 m_count = 0                                    
                 return true                                    
              end                                            
           else                                           
              return m_buffer.has() and m_count < n          
           end                                            
        end                                            
        s.next = next                                  
        s.hasNext = hasNext                            
        return s                                       
     end                                            
     function count()                               
        local m_count = 0                              
        while self.hasNext() do                        
           m_count = m_count + 1                          
           self.next()                                    
        end                                            
        return m_count                                 
     end                                            
     function forEach(func)                         
        if type(func) ~= "function" then               
           error("expected function, got " .. type(func)) 
        end                                            
        while self.hasNext() do                        
           func(self.next())                              
        end                                            
     end                                            
     function reduce(identity, accumulator)         
        local ret = stream.Optional()                  
        if accumulator then                            
           local result = identity                        
           while self.hasNext() do                        
              result = accumulator(result, self.next())      
           end                                            
           ret.set(result)                                
        else                                           
           accumulator = identity                         
           local result                                   
           local foundAny                                 
           while self.hasNext() do                        
              if foundAny then                               
                 result = accumulator(result, self.next())      
              else                                           
                 foundAny = true                                
                 result = self.next()                           
              end                                            
           end                                            
           if foundAny then                               
              ret.set(result)                                
           end                                            
        end                                            
        return ret                                     
     end                                            
     function findFirst()                           
        local ret = stream.Optional()                  
        if self.hasNext() then                         
           ret.set(self.next())                           
        end                                            
        return ret                                     
     end                                            
     function findLast()                            
        local ret = stream.Optional()                  
        while self.hasNext() do                        
           ret.set(self.next())                           
        end                                            
        return ret                                     
     end                                            
     function toArray()                             
        local res = {}                                 
        while self.hasNext() do                        
           table.insert(res, self.next())                 
        end                                            
        return res                                     
     end                                            
     function min(comparator)                       
        local ret = stream.Optional()                  
        local array = self.toArray()                   
        if #array > 0 then                             
           table.sort(array, comparator)                  
           ret.set(array[1])                              
        end                                            
        return ret                                     
     end                                            
     function max(comparator)                       
        local ret = stream.Optional()                  
        local array = self.toArray()                   
        if #array > 0 then                             
           table.sort(array, comparator)                  
           ret.set(array[#array])                         
        end                                            
        return ret                                     
     end                                            
     self.filter = filter                           
     self.limit = limit                             
     self.skip = skip                               
     self.stride = stride                           
     self.map = map                                 
     self.peek = peek                               
     self.concat = concat                           
     self.distinct = distinct                       
     self.recur = recur                             
     self.count = count                             
     self.forEach = forEach                         
     self.reduce = reduce                           
     self.findFirst = findFirst                     
     self.findLast = findLast                       
     self.toArray = toArray                         
     self.sorted = sorted                           
     self.min = min                                 
     self.max = max                                 
     return self                                    
  end                                            
  function stream.of(...)                        
     return stream.array({...})                     
  end                                            
  function stream.array(arr)                     
     if #arr == 0 then                              
        return stream.empty()                          
     elseif #arr == 1 then                          
        return stream.single(arr[1])                   
     end                                            
     local self = stream.Stream()                   
     local m_data = arr                             
     local m_index = 1                              
     local next                                     
     local hasNext                                  
     local count                                    
     function next()                                
        if not self.hasNext() then                     
           error("next element does not exist")           
        end                                            
        local value = m_data[m_index]                  
        m_index = m_index + 1                          
        return value                                   
     end                                            
     function hasNext()                             
        return m_index <= #m_data                      
     end                                            
     function count()                               
        return #m_data                                 
     end                                            
     self.next = next                               
     self.hasNext = hasNext                         
     self.count = count                             
     return self                                    
  end                                            
  function stream.iterate(seed, func)            
     local self = stream.Stream()                   
     local m_current = seed                         
     local next                                     
     local hasNext                                  
     function next()                                
        local value = m_current                        
        m_current = func(m_current)                    
        return value                                   
     end                                            
     function hasNext()                             
        return true                                    
     end                                            
     self.next = next                               
     self.hasNext = hasNext                         
     return self                                    
  end                                            
  function stream.generate(func)                 
     local self = stream.Stream()                   
     local next                                     
     local hasNext                                  
     function next()                                
        return func()                                  
     end                                            
     function hasNext()                             
        return true                                    
     end                                            
     self.next = next                               
     self.hasNext = hasNext                         
     return self                                    
  end                                            
  function stream.empty()                        
     local self = stream.Stream()                   
     local next                                     
     local hasNext                                  
     function next()                                
        if not self.hasNext() then                     
           error("next element does not exist")           
        end                                            
     end                                            
     function hasNext()                             
        return false                                   
     end                                            
     self.next = next                               
     self.hasNext = hasNext                         
     return self                                    
  end                                            
  function stream.single(element)                
     local self = stream.Stream()                   
     local m_buffer = Buffer()                      
     m_buffer.set(element)                          
     local next                                     
     local hasNext                                  
     function next()                                
        if not self.hasNext() then                     
           error("next element does not exist")           
        end                                            
        return m_buffer.get()                          
     end                                            
     function hasNext()                             
        return m_buffer.has()                          
     end                                            
     self.next = next                               
     self.hasNext = hasNext                         
     return self                                    
  end                                            
  function stream.concat(streamA, streamB)       
     local self = stream.Stream()                   
     local m_current = streamA                      
     local next                                     
     local hasNext                                  
     function next()                                
        if not self.hasNext() then                     
           error("next element does not exist")           
        end                                            
        return m_current.next()                        
     end                                            
     function hasNext()                             
        if m_current then                              
           if m_current.hasNext() then                    
              return true                                    
           else                                           
              if m_current == streamA then                   
                 m_current = streamB                            
                 return self.hasNext()                          
              else                                           
                 m_current = nil                                
                 return false                                   
              end                                            
           end                                            
        else                                           
           return false                                   
        end                                            
     end                                            
     self.next = next                               
     self.hasNext = hasNext                         
     return self                                    
  end                                            

#+END_SRC
